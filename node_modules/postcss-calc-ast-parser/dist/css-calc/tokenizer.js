"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const AST = require("../types/ast");
const unicode_1 = require("./util/unicode");
function isPunctuator(cc) {
    return cc === unicode_1.LPAREN || cc === unicode_1.RPAREN || cc === unicode_1.COMMA;
}
function maybeNumber(cc) {
    return unicode_1.isDigit(cc) || cc === unicode_1.DOT;
}
function isQuotes(cc) {
    return cc === unicode_1.DQUOTE || cc === unicode_1.SQUOTE;
}
function getRightBracket(cc) {
    if (cc === unicode_1.LPAREN) {
        return unicode_1.RPAREN;
    }
    if (cc === unicode_1.LBRACE) {
        return unicode_1.RBRACE;
    }
    return unicode_1.RBRACKET;
}
class Tokenizer {
    constructor(text, options) {
        this.lastCode = unicode_1.NULL;
        this.rescan = false;
        this.token = null;
        this.lastTokenType = null;
        this.errors = [];
        this.text = text;
        this.offset = -1;
        this.state = "SCAN";
        this.nextTokenOffset = 0;
        this.options = Object.assign({
            allowInlineCommnets: true,
        }, options || {});
    }
    nextToken() {
        while (this.token == null) {
            const cc = this.scan();
            this.state = this[this.state](cc) || "SCAN";
            if (cc === unicode_1.EOF && !this.rescan) {
                break;
            }
        }
        const { token } = this;
        this.token = null;
        return token;
    }
    scan() {
        if (this.rescan) {
            this.rescan = false;
            return this.lastCode;
        }
        return this.next();
    }
    next() {
        if (this.offset < this.text.length) {
            this.offset++;
        }
        if (this.offset >= this.text.length) {
            return (this.lastCode = unicode_1.EOF);
        }
        return (this.lastCode = this.text.charCodeAt(this.offset));
    }
    back() {
        this.rescan = true;
    }
    reportParseError(code) {
        const error = AST.ParseError.fromCode(code, this.offset);
        this.errors.push(error);
    }
    getCode(indexOffset = 0) {
        return this.text.charCodeAt(this.nextTokenOffset + indexOffset);
    }
    commitToken(type, indexOffset = 0) {
        const start = this.nextTokenOffset;
        const offset = this.offset + indexOffset + 1;
        const value = this.text.slice(start, offset);
        this.token = {
            type,
            value,
            source: {
                start: {
                    index: start,
                },
                end: {
                    index: offset,
                },
            },
        };
        this.nextTokenOffset = offset;
        this.lastTokenType = type;
    }
    SCAN(cc) {
        if (unicode_1.isWhitespace(cc)) {
            return "WHITESPACE";
        }
        if (cc === unicode_1.DQUOTE) {
            return "DQUOTE";
        }
        if (cc === unicode_1.SQUOTE) {
            return "SQUOTE";
        }
        if (cc === unicode_1.SLASH) {
            return "SLASH";
        }
        if (cc === unicode_1.MINUS) {
            return "MINUS";
        }
        if (cc === unicode_1.PLUS) {
            return "PLUS";
        }
        if (cc === unicode_1.STAR) {
            this.commitToken("operator");
            return "SCAN";
        }
        if (isPunctuator(cc)) {
            this.commitToken("punctuator");
            return "SCAN";
        }
        if (cc === unicode_1.LBRACKET) {
            return "LBRACKET";
        }
        if (cc === unicode_1.LBRACE) {
            return "LBRACE";
        }
        if (cc === unicode_1.EOF) {
            return "SCAN";
        }
        return "WORD";
    }
    WORD(cc) {
        while (!unicode_1.isWhitespace(cc) &&
            !isPunctuator(cc) &&
            cc !== unicode_1.PLUS &&
            cc !== unicode_1.STAR &&
            cc !== unicode_1.SLASH &&
            !isQuotes(cc) &&
            cc !== unicode_1.EOF) {
            if (cc === unicode_1.MINUS) {
                const st = this.getCode();
                if (maybeNumber(st) ||
                    ((st === unicode_1.MINUS || st === unicode_1.PLUS) &&
                        maybeNumber(this.getCode(1)))) {
                    this.commitToken("word", -1);
                    return "MINUS";
                }
            }
            else if (cc === unicode_1.LBRACE || cc === unicode_1.LBRACKET || cc === unicode_1.LPAREN) {
                this.skipBrakets(this.next(), getRightBracket(cc));
            }
            cc = this.next();
        }
        this.commitToken("word", -1);
        this.back();
    }
    LBRACKET(cc) {
        this.skipBrakets(cc, unicode_1.RBRACKET);
        return "WORD";
    }
    LBRACE(cc) {
        this.skipBrakets(cc, unicode_1.RBRACE);
        return "WORD";
    }
    WHITESPACE(cc) {
        while (unicode_1.isWhitespace(cc)) {
            cc = this.next();
        }
        this.commitToken("whitespace", -1);
        this.back();
    }
    SLASH(cc) {
        if (cc === unicode_1.STAR) {
            return "COMMENT";
        }
        if (cc === unicode_1.SLASH && this.options.allowInlineCommnets) {
            return "INLINE_COMMENT";
        }
        this.commitToken("operator", -1);
        this.back();
    }
    COMMENT(cc) {
        while (cc !== unicode_1.EOF) {
            if (cc === unicode_1.STAR) {
                cc = this.next();
                if (cc === unicode_1.SLASH) {
                    this.commitToken("comment");
                    return;
                }
            }
            cc = this.next();
        }
        this.commitToken("comment", -1);
        this.reportParseError("eof-in-comment");
    }
    INLINE_COMMENT(cc) {
        while (cc !== unicode_1.EOF) {
            if (cc === unicode_1.LF || cc === unicode_1.FF) {
                this.commitToken("inline-comment");
                return;
            }
            if (cc === unicode_1.CR) {
                cc = this.next();
                if (cc === unicode_1.LF) {
                    this.commitToken("inline-comment");
                    return;
                }
                this.commitToken("inline-comment", -1);
                return this.back();
            }
            cc = this.next();
        }
        this.commitToken("inline-comment", -1);
    }
    MINUS(cc) {
        if (this.lastTokenType === "word" ||
            cc === unicode_1.EOF ||
            (cc !== unicode_1.MINUS && !maybeNumber(cc) && !unicode_1.isLetter(cc))) {
            this.commitToken("operator", -1);
            this.back();
            return;
        }
        return "WORD";
    }
    PLUS(cc) {
        if (this.lastTokenType !== "word") {
            if (maybeNumber(cc)) {
                return "WORD";
            }
        }
        this.commitToken("operator", -1);
        this.back();
    }
    DQUOTE(cc) {
        this.skipString(cc, unicode_1.DQUOTE);
    }
    SQUOTE(cc) {
        this.skipString(cc, unicode_1.SQUOTE);
    }
    skipBrakets(cc, end) {
        const closeStack = [];
        while (cc !== unicode_1.EOF) {
            if (end === cc) {
                const nextTargetBracket = closeStack.pop() || null;
                if (!nextTargetBracket) {
                    return;
                }
                end = nextTargetBracket;
            }
            else if (cc === unicode_1.LBRACE || cc === unicode_1.LBRACKET || cc === unicode_1.LPAREN) {
                if (end) {
                    closeStack.push(end);
                }
                end = getRightBracket(cc);
            }
            cc = this.next();
        }
        this.reportParseError("eof-in-bracket");
    }
    skipString(cc, end) {
        while (cc !== unicode_1.EOF) {
            if (cc === unicode_1.BACKSLASH) {
                cc = this.next();
            }
            else if (cc === end) {
                this.commitToken("string");
                return;
            }
            cc = this.next();
        }
        this.commitToken("string", -1);
        this.reportParseError("eof-in-string");
    }
}
exports.Tokenizer = Tokenizer;
