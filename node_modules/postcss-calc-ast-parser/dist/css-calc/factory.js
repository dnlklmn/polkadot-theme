"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const valueParserUnit = require("postcss-value-parser/lib/unit");
const Impl = require("./util/node-impl");
const LENGTH_UNITS = [
    "em",
    "ex",
    "ch",
    "rem",
    "vw",
    "vh",
    "vmin",
    "vmax",
    "px",
    "mm",
    "cm",
    "in",
    "pt",
    "pc",
    "Q",
    "vm",
];
const ANGLE_UNITS = ["deg", "grad", "turn", "rad"];
const TIME_UNITS = ["s", "ms"];
const FREQUENCY_UNITS = ["Hz", "kHz"];
const RESOLUTION_UNITS = ["dpi", "dpcm", "dppm"];
const FLEX_UNITS = ["fr"];
const L_LENGTH_UNITS = LENGTH_UNITS.map(u => u.toLowerCase());
const L_ANGLE_UNITS = ANGLE_UNITS.map(u => u.toLowerCase());
const L_TIME_UNITS = TIME_UNITS.map(u => u.toLowerCase());
const L_FREQUENCY_UNITS = FREQUENCY_UNITS.map(u => u.toLowerCase());
const L_RESOLUTION_UNITS = RESOLUTION_UNITS.map(u => u.toLowerCase());
const L_FLEX_UNITS = FLEX_UNITS.map(u => u.toLowerCase());
function newPunctuator(token, before) {
    if (token.value === "," || token.value === ")") {
        return newTokenNode(Impl.Punctuator, token, token.value, before);
    }
    throw new Error(`illegal argument error "${token.value}"`);
}
exports.newPunctuator = newPunctuator;
function newOperator(token, before) {
    return newTokenNode(Impl.Operator, token, token.value, before);
}
exports.newOperator = newOperator;
function newString(token, before) {
    return newTokenNode(Impl.StringNode, token, token.value, before);
}
exports.newString = newString;
function newWordNode(token, before) {
    return newValueNode(token, before);
}
exports.newWordNode = newWordNode;
function newFunction(token, before, open) {
    return new Impl.FunctionNode(token.value, before, {
        start: token.source.start,
        end: open.source.end,
    });
}
exports.newFunction = newFunction;
function newParentheses(token, before) {
    return new Impl.Parentheses(before, {
        start: token.source.start,
        end: token.source.end,
    });
}
exports.newParentheses = newParentheses;
function newMathExpression(left, op, right) {
    const opNode = typeof op === "string"
        ? newTokenNode(Impl.Operator, { source: { start: { index: 0 }, end: { index: 0 } } }, op, " ")
        : op;
    const { before } = left.raws;
    left.raws.before = "";
    return new Impl.MathExpression(left, opNode, right, before, {
        start: left.source.start,
        operator: opNode.source,
        end: right.source.end,
    });
}
exports.newMathExpression = newMathExpression;
function newValueNode(token, before) {
    if (token.type === "word") {
        const parsedUnit = valueParserUnit(token.value);
        if (parsedUnit) {
            const n = newNumNode(parsedUnit, token, before);
            if (n) {
                return n;
            }
        }
    }
    return newTokenNode(Impl.Word, token, token.value, before);
}
function newNumNode(parsedUnit, token, before) {
    const { source } = token;
    if (!parsedUnit.unit) {
        return new Impl.NumberValue(parsedUnit.number, before, source);
    }
    const lunit = parsedUnit.unit.toLowerCase();
    function unitNode(WithUnitValue, unit) {
        const n = new WithUnitValue(parsedUnit.number, unit, before, source);
        if (unit !== parsedUnit.unit) {
            n.raws.unit = {
                raw: parsedUnit.unit,
                value: unit,
            };
        }
        return n;
    }
    let unitIndex;
    if ((unitIndex = L_LENGTH_UNITS.indexOf(lunit)) >= 0) {
        return unitNode(Impl.LengthValue, LENGTH_UNITS[unitIndex]);
    }
    if ((unitIndex = L_ANGLE_UNITS.indexOf(lunit)) >= 0) {
        return unitNode(Impl.AngleValue, ANGLE_UNITS[unitIndex]);
    }
    if ((unitIndex = L_TIME_UNITS.indexOf(lunit)) >= 0) {
        return unitNode(Impl.TimeValue, TIME_UNITS[unitIndex]);
    }
    if ((unitIndex = L_FREQUENCY_UNITS.indexOf(lunit)) >= 0) {
        return unitNode(Impl.FrequencyValue, FREQUENCY_UNITS[unitIndex]);
    }
    if ((unitIndex = L_RESOLUTION_UNITS.indexOf(lunit)) >= 0) {
        return unitNode(Impl.ResolutionValue, RESOLUTION_UNITS[unitIndex]);
    }
    if ((unitIndex = L_FLEX_UNITS.indexOf(lunit)) >= 0) {
        return unitNode(Impl.FlexValue, FLEX_UNITS[unitIndex]);
    }
    if (lunit === "%") {
        return unitNode(Impl.PercentageValue, "%");
    }
    return null;
}
function newTokenNode(TokenValue, token, value, before) {
    const { source } = token;
    return new TokenValue(value, before, source);
}
