import * as AST from "../../types/ast";
import { Stringifier } from "../stringifier";
declare type Stringify = (node: AST.INode | AST.IToken) => string;
declare abstract class Node implements AST.INode {
    abstract type: string;
    abstract raws: {
        before: string;
    } | {
        after: string;
    };
    abstract source: AST.SourceLocation;
    parent: AST.IContainer | null;
    toString(stringifier?: Stringifier | Stringify): string;
    walk(type: string | RegExp, callback: (node: any) => boolean | void): boolean | void;
}
declare abstract class Container extends Node implements AST.IContainer {
    abstract nodes: AST.INode[];
    push(...children: AST.INode[]): this;
    unshift(...children: AST.INode[]): this;
    append(...children: AST.INode[]): this;
    prepend(...children: AST.INode[]): this;
    insertBefore(exist: AST.INode, add: AST.INode): this;
    insertAfter(exist: AST.INode, add: AST.INode): this;
    removeAll(): this;
    removeChild(child: AST.INode): this;
    readonly first: AST.INode | null;
    readonly last: AST.INode | null;
}
export declare class NumberValue extends Node implements AST.NumberValue {
    type: "Number";
    value: number;
    raws: {
        before: string;
        value: {
            raw: string;
            value: number;
        };
    };
    source: AST.SourceLocation;
    constructor(value: string, before: string, source: AST.SourceLocation);
}
declare abstract class NumWithUnitValue<T extends string, U> extends Node {
    type: T;
    value: number;
    unit: U;
    raws: {
        before: string;
        value: {
            raw: string;
            value: number;
        };
        unit?: {
            raw: string;
            value: U;
        };
    };
    source: AST.SourceLocation;
    constructor(type: T, value: string, unit: U, before: string, source: AST.SourceLocation);
}
export declare class LengthValue extends NumWithUnitValue<"Length", AST.LengthUnit> implements AST.LengthValue {
    constructor(value: string, unit: AST.LengthUnit, before: string, source: AST.SourceLocation);
}
export declare class AngleValue extends NumWithUnitValue<"Angle", AST.AngleUnit> implements AST.AngleValue {
    constructor(value: string, unit: AST.AngleUnit, before: string, source: AST.SourceLocation);
}
export declare class TimeValue extends NumWithUnitValue<"Time", AST.TimeUnit> implements AST.TimeValue {
    constructor(value: string, unit: AST.TimeUnit, before: string, source: AST.SourceLocation);
}
export declare class FrequencyValue extends NumWithUnitValue<"Frequency", AST.FrequencyUnit> implements AST.FrequencyValue {
    constructor(value: string, unit: AST.FrequencyUnit, before: string, source: AST.SourceLocation);
}
export declare class ResolutionValue extends NumWithUnitValue<"Resolution", AST.ResolutionUnit> implements AST.ResolutionValue {
    constructor(value: string, unit: AST.ResolutionUnit, before: string, source: AST.SourceLocation);
}
export declare class PercentageValue extends NumWithUnitValue<"Percentage", "%"> implements AST.PercentageValue {
    constructor(value: string, unit: "%", before: string, source: AST.SourceLocation);
}
export declare class FlexValue extends NumWithUnitValue<"Flex", AST.FlexUnit> implements AST.FlexValue {
    constructor(value: string, unit: AST.FlexUnit, before: string, source: AST.SourceLocation);
}
declare abstract class TokenValue<T extends string, V extends string> extends Node {
    type: T;
    value: V;
    raws: {
        before: string;
    };
    source: AST.SourceLocation;
    constructor(type: T, value: V, before: string, source: AST.SourceLocation);
}
export declare class Word extends TokenValue<"Word", string> implements AST.Word {
    constructor(value: string, before: string, source: AST.SourceLocation);
}
export declare class StringNode extends TokenValue<"String", string> implements AST.StringNode {
    constructor(value: string, before: string, source: AST.SourceLocation);
}
export declare class MathExpression extends Node implements AST.MathExpression {
    type: "MathExpression";
    left: AST.Expression;
    operator: "+" | "-" | "*" | "/";
    right: AST.Expression;
    raws: {
        before: string;
        between: string;
    };
    source: {
        operator: AST.SourceLocation;
    } & AST.SourceLocation;
    constructor(left: AST.Expression, operator: AST.Operator, right: AST.Expression, before: string, source: {
        operator: AST.SourceLocation;
    } & AST.SourceLocation);
}
export declare class FunctionNode extends Container implements AST.FunctionNode {
    type: "Function";
    nodes: AST.Expression[];
    name: string;
    raws: {
        before: string;
        beforeClose?: string;
    };
    source: AST.SourceLocation;
    unclosed?: boolean;
    constructor(name: string, before: string, source: AST.SourceLocation);
}
export declare class Parentheses extends Container implements AST.Parentheses {
    type: "Parentheses";
    nodes: AST.Expression[];
    raws: {
        before: string;
        beforeClose?: string;
    };
    source: AST.SourceLocation;
    unclosed?: boolean;
    constructor(before: string, source: AST.SourceLocation);
}
export declare class Punctuator extends TokenValue<"Punctuator", "," | ")"> implements AST.Punctuator {
    constructor(value: "," | ")", before: string, source: AST.SourceLocation);
}
export declare class Root extends Container implements AST.Root {
    type: "Root";
    nodes: AST.Expression[];
    tokens: AST.Token[];
    errors: AST.ParseError[];
    raws: {
        after: string;
    };
    source: AST.SourceLocation;
    constructor(source: AST.SourceLocation);
}
export declare class Operator extends TokenValue<"Operator", "+" | "-" | "*" | "/"> implements AST.Operator {
    constructor(value: "+" | "-" | "*" | "/", before: string, source: AST.SourceLocation);
}
export {};
