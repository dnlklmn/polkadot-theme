"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const stringifier_1 = require("../stringifier");
let defaultStringifier = null;
class Node {
    constructor() {
        this.parent = null;
    }
    toString(stringifier) {
        if (typeof stringifier === "function") {
            return stringifier(this);
        }
        return (stringifier ||
            defaultStringifier ||
            (defaultStringifier = new stringifier_1.Stringifier())).stringify(this);
    }
    walk(type, callback) {
        const node = this;
        let result = undefined;
        const nodes = [...(node.nodes || []), node.left, node.right].filter(n => Boolean(n));
        const check = typeof type === "string"
            ? (n) => n.type === type
            : (n) => type.test(n.type);
        for (const child of nodes) {
            if (check(child)) {
                result = callback(child);
                if (result === false) {
                    break;
                }
            }
            if (child.walk) {
                result = child.walk(type, callback);
                if (result === false) {
                    break;
                }
            }
        }
        return result;
    }
}
class Container extends Node {
    push(...children) {
        for (const child of children) {
            if (child.type === "Root") {
                this.push(...child.nodes);
            }
            else {
                child.parent = this;
                this.nodes.push(child);
            }
        }
        return this;
    }
    unshift(...children) {
        for (const child of children.reverse()) {
            if (child.type === "Root") {
                this.unshift(...child.nodes);
            }
            else {
                child.parent = this;
                this.nodes.unshift(child);
            }
        }
        return this;
    }
    append(...children) {
        return this.push(...children);
    }
    prepend(...children) {
        return this.unshift(...children);
    }
    insertBefore(exist, add) {
        if (add.type === "Root") {
            const { nodes } = add;
            if (nodes.length === 1) {
                return this.insertBefore(exist, nodes[0]);
            }
            throw new Error("The given Root node is illegal.");
        }
        const existIndex = this.nodes.indexOf(exist);
        if (existIndex < 0) {
            throw new Error("The given node could not be found.");
        }
        add.parent = this;
        this.nodes.splice(existIndex, 0, add);
        return this;
    }
    insertAfter(exist, add) {
        if (add.type === "Root") {
            const { nodes } = add;
            if (nodes.length === 1) {
                return this.insertAfter(exist, nodes[0]);
            }
            throw new Error("The given Root node is illegal.");
        }
        const existIndex = this.nodes.indexOf(exist);
        if (existIndex < 0) {
            throw new Error("The given node could not be found.");
        }
        add.parent = this;
        this.nodes.splice(existIndex + 1, 0, add);
        return this;
    }
    removeAll() {
        for (const node of this.nodes) {
            node.parent = null;
        }
        this.nodes = [];
        return this;
    }
    removeChild(child) {
        const index = this.nodes.indexOf(child);
        this.nodes[index].parent = null;
        this.nodes.splice(index, 1);
        return this;
    }
    get first() {
        return this.nodes[0] || null;
    }
    get last() {
        return this.nodes[this.nodes.length - 1] || null;
    }
}
class NumberValue extends Node {
    constructor(value, before, source) {
        super();
        const num = parseFloat(value);
        this.type = "Number";
        this.value = num;
        this.raws = {
            before,
            value: {
                raw: value,
                value: num,
            },
        };
        this.source = source;
    }
}
exports.NumberValue = NumberValue;
class NumWithUnitValue extends Node {
    constructor(type, value, unit, before, source) {
        super();
        const num = parseFloat(value);
        this.type = type;
        this.value = num;
        this.unit = unit;
        this.raws = {
            before,
            value: {
                raw: value,
                value: num,
            },
        };
        this.source = source;
    }
}
class LengthValue extends NumWithUnitValue {
    constructor(value, unit, before, source) {
        super("Length", value, unit, before, source);
    }
}
exports.LengthValue = LengthValue;
class AngleValue extends NumWithUnitValue {
    constructor(value, unit, before, source) {
        super("Angle", value, unit, before, source);
    }
}
exports.AngleValue = AngleValue;
class TimeValue extends NumWithUnitValue {
    constructor(value, unit, before, source) {
        super("Time", value, unit, before, source);
    }
}
exports.TimeValue = TimeValue;
class FrequencyValue extends NumWithUnitValue {
    constructor(value, unit, before, source) {
        super("Frequency", value, unit, before, source);
    }
}
exports.FrequencyValue = FrequencyValue;
class ResolutionValue extends NumWithUnitValue {
    constructor(value, unit, before, source) {
        super("Resolution", value, unit, before, source);
    }
}
exports.ResolutionValue = ResolutionValue;
class PercentageValue extends NumWithUnitValue {
    constructor(value, unit, before, source) {
        super("Percentage", value, unit, before, source);
    }
}
exports.PercentageValue = PercentageValue;
class FlexValue extends NumWithUnitValue {
    constructor(value, unit, before, source) {
        super("Flex", value, unit, before, source);
    }
}
exports.FlexValue = FlexValue;
class TokenValue extends Node {
    constructor(type, value, before, source) {
        super();
        this.type = type;
        this.value = value;
        this.raws = {
            before,
        };
        this.source = source;
    }
}
class Word extends TokenValue {
    constructor(value, before, source) {
        super("Word", value, before, source);
    }
}
exports.Word = Word;
class StringNode extends TokenValue {
    constructor(value, before, source) {
        super("String", value, before, source);
    }
}
exports.StringNode = StringNode;
function defineAssessor(obj, name, setterProc) {
    const localName = Symbol(`${name}`);
    Object.defineProperties(obj, {
        [localName]: { writable: true, enumerable: false },
        [name]: {
            get() {
                return this[localName];
            },
            set(n) {
                const o = this[localName];
                this[localName] = setterProc(n, o);
            },
            enumerable: true,
        },
    });
}
class MathExpression extends Node {
    constructor(left, operator, right, before, source) {
        super();
        const ope = operator.value;
        const between = operator.raws.before;
        this.type = "MathExpression";
        const setterProc = (n, o) => {
            let e;
            if (n.type === "Root") {
                const { nodes } = n;
                if (nodes.length === 1) {
                    e = nodes[0];
                }
                else {
                    throw new Error("The given Root node is illegal.");
                }
            }
            else {
                e = n;
            }
            e.parent = this;
            if (o) {
                o.parent = null;
            }
            return e;
        };
        defineAssessor(this, "left", setterProc);
        this.left = left;
        this.operator = ope;
        defineAssessor(this, "right", setterProc);
        this.right = right;
        this.raws = { before, between };
        this.source = source;
    }
}
exports.MathExpression = MathExpression;
class FunctionNode extends Container {
    constructor(name, before, source) {
        super();
        this.type = "Function";
        this.name = name;
        this.nodes = [];
        this.raws = { before };
        this.source = source;
    }
}
exports.FunctionNode = FunctionNode;
class Parentheses extends Container {
    constructor(before, source) {
        super();
        this.type = "Parentheses";
        this.nodes = [];
        this.raws = { before };
        this.source = source;
    }
}
exports.Parentheses = Parentheses;
class Punctuator extends TokenValue {
    constructor(value, before, source) {
        super("Punctuator", value, before, source);
    }
}
exports.Punctuator = Punctuator;
class Root extends Container {
    constructor(source) {
        super();
        this.type = "Root";
        this.nodes = [];
        this.tokens = [];
        this.errors = [];
        this.raws = { after: "" };
        this.source = source;
    }
}
exports.Root = Root;
class Operator extends TokenValue {
    constructor(value, before, source) {
        super("Operator", value, before, source);
    }
}
exports.Operator = Operator;
