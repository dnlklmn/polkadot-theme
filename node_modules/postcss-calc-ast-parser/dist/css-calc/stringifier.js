"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function rawVal(node, name) {
    const r = node.raws[name];
    return r ? r.raw : `${node[name]}`;
}
function raw(node, name) {
    const r = node.raws[name];
    return r || "";
}
function wrapRaws(node, inner) {
    return `${raw(node, "before")}${inner}`;
}
function numWithUnit(node) {
    return wrapRaws(node, `${rawVal(node, "value")}${rawVal(node, "unit")}`);
}
class Stringifier {
    constructor(options) {
        this.options = Object.assign({
            autofix: false,
        }, options || {});
    }
    stringify(node) {
        return this[node.type](node);
    }
    Root(node) {
        let s = "";
        for (const c of node.nodes) {
            s += this.stringify(c);
        }
        s += raw(node, "after");
        return s;
    }
    Function(node) {
        let s = `${node.name}(`;
        for (const c of node.nodes) {
            s += this.stringify(c);
        }
        s += raw(node, "beforeClose");
        if (this.options.autofix || !node.unclosed) {
            s += ")";
        }
        return wrapRaws(node, s);
    }
    Parentheses(node) {
        let s = "(";
        for (const c of node.nodes) {
            s += this.stringify(c);
        }
        s += raw(node, "beforeClose");
        if (this.options.autofix || !node.unclosed) {
            s += ")";
        }
        return wrapRaws(node, s);
    }
    MathExpression(node) {
        let beforeLeft = "";
        let between = raw(node, "between");
        let beforeRight = "";
        let afterRight = "";
        if (this.options.autofix) {
            if (!between) {
                between = " ";
            }
            if (!node.right.raws.before) {
                beforeRight = " ";
            }
            if (node.left.type === "MathExpression") {
                if ((node.left.operator === "+" ||
                    node.left.operator === "-") &&
                    (node.operator === "*" || node.operator === "/")) {
                    beforeLeft += "(";
                    between = `)${between}`;
                }
            }
            if (node.right.type === "MathExpression") {
                if ((node.operator === "+" && node.right.operator === "-") ||
                    ((node.operator === "-" || node.operator === "*") &&
                        (node.right.operator === "+" ||
                            node.right.operator === "-")) ||
                    node.operator === "/") {
                    beforeRight += "(";
                    afterRight = `)${afterRight}`;
                }
            }
        }
        return wrapRaws(node, `${beforeLeft}${this.stringify(node.left)}${between}${node.operator}${beforeRight}${this.stringify(node.right)}${afterRight}`);
    }
    Number(node) {
        return wrapRaws(node, rawVal(node, "value"));
    }
    Punctuator(node) {
        return wrapRaws(node, node.value);
    }
    Word(node) {
        return wrapRaws(node, node.value);
    }
    String(node) {
        return wrapRaws(node, node.value);
    }
    Operator(node) {
        return wrapRaws(node, node.value);
    }
    Length(node) {
        return numWithUnit(node);
    }
    Angle(node) {
        return numWithUnit(node);
    }
    Time(node) {
        return numWithUnit(node);
    }
    Frequency(node) {
        return numWithUnit(node);
    }
    Resolution(node) {
        return numWithUnit(node);
    }
    Percentage(node) {
        return numWithUnit(node);
    }
    Flex(node) {
        return numWithUnit(node);
    }
    word(node) {
        return node.value;
    }
    punctuator(node) {
        return node.value;
    }
    operator(node) {
        return node.value;
    }
    whitespace(node) {
        return node.value;
    }
    comment(node) {
        return node.value;
    }
    string(node) {
        return node.value;
    }
    "inline-comment"(node) {
        return node.value;
    }
}
exports.Stringifier = Stringifier;
