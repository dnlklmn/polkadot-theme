"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const AST = require("../types/ast");
const Impl = require("./util/node-impl");
const factory_1 = require("./factory");
const calc_notation_1 = require("./util/calc-notation");
const utils_1 = require("./util/utils");
const MAYBE_FUNCTION = /^([^-+0-9.]|-[^+0-9.])/u;
const PRECEDENCE = {
    "*": 3,
    "/": 3,
    "+": 2,
    "-": 2,
};
function srcLoc(node) {
    return node.source || { start: { index: 0 }, end: { index: 0 } };
}
function isExpression(node) {
    if (node && node.type !== "Punctuator" && node.type !== "Operator") {
        return node;
    }
    return null;
}
class Parser {
    constructor(tokenizer, _options) {
        this.tokenizer = tokenizer;
        this.root = new Impl.Root({
            start: {
                index: 0,
            },
            end: {
                index: 0,
            },
        });
        this.rescans = [];
        this.tokens = this.root.tokens;
        this.errors = this.root.errors;
    }
    parse() {
        let state = {
            container: this.root,
            fnName: "",
            post() {
            },
            eof() {
            },
        };
        while (state) {
            state = this.processExpressions(state);
        }
        const { tokens } = this;
        if (tokens.length > 0) {
            srcLoc(this.root).end.index =
                tokens[tokens.length - 1].source.end.index;
        }
        this.errors.unshift(...this.tokenizer.errors);
        this.errors.sort((e1, e2) => e1.index - e2.index);
        return this.root;
    }
    reportParseError(code, index = 0) {
        if (this.errors.find(e => e.code === code && e.index === index)) {
            return;
        }
        const error = AST.ParseError.fromCode(code, index);
        this.errors.push(error);
    }
    processExpressions(state) {
        let tokenSet;
        while ((tokenSet = this.scan())) {
            const { token } = tokenSet;
            switch (token.type) {
                case "word":
                    if (MAYBE_FUNCTION.test(token.value)) {
                        const next = this.scan();
                        if (next) {
                            if (!next.raws &&
                                next.token.type === "punctuator" &&
                                next.token.value === "(") {
                                return this.processFunction(token, tokenSet.raws, next.token, state);
                            }
                            this.back(next);
                        }
                    }
                    state.container.push(factory_1.newWordNode(token, tokenSet.raws));
                    break;
                case "string":
                    state.container.push(factory_1.newString(token, tokenSet.raws));
                    break;
                case "operator":
                    this.checkAndMergeMathExpr(state, PRECEDENCE[token.value]);
                    state.container.push(factory_1.newOperator(token, tokenSet.raws));
                    break;
                case "punctuator":
                    this.checkAndMergeMathExpr(state);
                    return this.processPunctuator(token, tokenSet.raws, state);
                default:
                    break;
            }
        }
        this.postStack(state);
        state.eof();
        return null;
    }
    checkAndMergeMathExpr(state, currPrecedence) {
        const { container } = state;
        const { nodes } = container;
        if (nodes.length >= 3) {
            const bfOp = nodes[nodes.length - 2];
            if (bfOp.type === "Operator" && PRECEDENCE[bfOp.value]) {
                if (currPrecedence == null ||
                    currPrecedence <= PRECEDENCE[bfOp.value]) {
                    const math = this.mergeMathExpr(state);
                    if (math) {
                        container.push(math);
                    }
                }
            }
        }
    }
    processPunctuator(token, before, state) {
        const { container, parent } = state;
        if (token.value === "(") {
            const node = factory_1.newParentheses(token, before);
            container.push(node);
            return this.createNestedStateContainer(node, state.fnName, state);
        }
        this.postStack(state);
        if (token.value === ")") {
            if (parent) {
                state.post(token, before);
                return parent;
            }
            this.reportParseError("unexpected-parenthesis", token.source.start.index);
        }
        container.push(factory_1.newPunctuator(token, before));
        return state;
    }
    processFunction(token, before, open, state) {
        const node = factory_1.newFunction(token, before, open);
        state.container.push(node);
        return this.createNestedStateContainer(node, node.name, state);
    }
    createNestedStateContainer(node, fnName, state) {
        return {
            container: node,
            parent: state,
            fnName,
            post(close, beforeClose) {
                if (beforeClose) {
                    node.raws.beforeClose = beforeClose;
                }
                srcLoc(node).end = close.source.end;
            },
            eof: () => {
                node.unclosed = true;
                const last = this.tokens[this.tokens.length - 1];
                const lastChild = node.last;
                if (lastChild) {
                    srcLoc(node).end = srcLoc(lastChild).end;
                }
                this.reportParseError("eof-in-bracket", last.source.end.index);
                state.eof();
            },
        };
    }
    mergeMathExpr(state) {
        const { container: { nodes }, } = state;
        const right = nodes.pop();
        const op = nodes.pop();
        const left = nodes.pop() || null;
        const restore = () => {
            if (left) {
                nodes.push(left);
            }
            nodes.push(op, right);
        };
        const reportError = (node) => {
            if (calc_notation_1.isMathFunction(state.fnName)) {
                this.reportParseError("unexpected-calc-token", srcLoc(node).start.index);
            }
        };
        const rightExpr = isExpression(right);
        if (utils_1.isComma(op)) {
            if (!rightExpr) {
                reportError(right);
            }
            restore();
            return null;
        }
        if (!left) {
            reportError(isExpression(op) ? right : op);
            restore();
            return null;
        }
        const leftExpr = isExpression(left);
        if (!leftExpr) {
            reportError(isExpression(nodes[nodes.length - 1]) ? op : left);
            restore();
            return null;
        }
        if (op.type !== "Operator") {
            reportError(op);
            restore();
            return null;
        }
        if (!rightExpr) {
            reportError(right);
            restore();
            return null;
        }
        return factory_1.newMathExpression(leftExpr, op, rightExpr);
    }
    postStack(state) {
        const { container } = state;
        const { nodes } = container;
        while (nodes.length > 1) {
            const math = this.mergeMathExpr(state);
            if (math) {
                container.push(math);
            }
            else {
                return;
            }
        }
    }
    scan() {
        const re = this.rescans.shift();
        if (re) {
            return re;
        }
        let raws = "";
        let token = this.tokenizer.nextToken();
        while (token) {
            this.tokens.push(token);
            if (token.type === "whitespace" ||
                token.type === "comment" ||
                token.type === "inline-comment") {
                raws += token.value;
            }
            else {
                return {
                    token,
                    raws,
                };
            }
            token = this.tokenizer.nextToken();
        }
        if (raws) {
            this.root.raws.after = raws;
        }
        return null;
    }
    back(tokenset) {
        this.rescans.unshift(tokenset);
    }
}
exports.Parser = Parser;
