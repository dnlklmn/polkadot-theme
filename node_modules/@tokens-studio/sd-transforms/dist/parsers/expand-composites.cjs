'use strict';

var TransformOptions = require('../TransformOptions.cjs');

const typeMaps = {
    boxShadow: {
        x: 'dimension',
        y: 'dimension',
        blur: 'dimension',
        spread: 'dimension',
        type: 'other',
    },
    border: {
        width: 'borderWidth',
        style: 'other',
    },
    composition: {},
    typography: {
        fontFamily: 'fontFamilies',
        fontWeight: 'fontWeights',
        lineHeight: 'lineHeights',
        fontSize: 'fontSizes',
    },
};
function expandToken(compToken, isShadow = false) {
    const expandedObj = {};
    const getType = (key) => typeMaps[compToken.type][key] ?? key;
    // multi-shadow
    if (isShadow && Array.isArray(compToken.value)) {
        compToken.value.forEach((shadow, index) => {
            expandedObj[index + 1] = {};
            Object.entries(shadow).forEach(([key, value]) => {
                expandedObj[index + 1][key] = {
                    value: `${value}`,
                    type: getType(key),
                };
            });
        });
    }
    else {
        Object.entries(compToken.value).forEach(([key, value]) => {
            expandedObj[key] = {
                value: `${value}`,
                type: getType(key),
            };
        });
    }
    return expandedObj;
}
function shouldExpand(token, condition, filePath) {
    if (typeof condition === 'function') {
        return condition(token, filePath);
    }
    return condition;
}
function recurse(slice, filePath, transformOpts = {}) {
    const opts = {
        ...transformOpts,
        expand: {
            composition: true,
            typography: false,
            border: false,
            shadow: false,
            ...(transformOpts.expand || {}),
        },
    };
    for (const key in slice) {
        const token = slice[key];
        const { type } = token;
        if (token.value && type) {
            if (typeof type === 'string' && TransformOptions.expandablesAsStringsArr.includes(type)) {
                const expandType = type === 'boxShadow' ? 'shadow' : type;
                const expand = shouldExpand(token, opts.expand[expandType], filePath);
                if (expand) {
                    slice[key] = expandToken(token, expandType === 'shadow');
                }
            }
        }
        else if (typeof token === 'object') {
            // TODO: figure out why we have to hack this typecast, if a value doesn't have a value & type,
            // it is definitely a nested DeepKeyTokenMap and not a SingleToken, but TS seems to think it must be
            // a SingleToken after this if statement
            recurse(token, filePath, transformOpts);
        }
    }
}
function expandComposites(dictionary, filePath, transformOpts) {
    const copy = { ...dictionary };
    recurse(copy, filePath, transformOpts);
    return copy;
}

exports.expandComposites = expandComposites;
exports.expandToken = expandToken;
